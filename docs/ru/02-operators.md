# Interton: операторы и выражения (детально)

Целевая версия: `Interton beta-v_.6.1`

Этот раздел описывает операторы с привязкой к реальному поведению рантайма и парсера.

## 1. Короткая карта операторов

Поддерживаются:

1. арифметика: `+`, `-`, `*`, `/`, `%`, `%%`, `//`, `**`,
2. присваивание: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `%%=`, `//=`, `**=`, `^=`,
3. сравнения: `==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=`, `<>`, `><`,
4. логика: `&&`, `||`, `!`,
5. битовые: `&`, `|`, `^`, `~`, `<<`, `>>`,
6. диапазон и конвейер: `..`, `|>`,
7. прочее: `?` (тернарный), `->`, `::`, `@measure`, `@entangle`, `@tensor`.

## 2. Главный момент про `<>` и `><`

Это не просто синонимы `<` и `>`.

1. `a >< b` возвращает максимум из `a` и `b`.
2. `a <> b` возвращает минимум из `a` и `b`.

То есть это операторы выбора значения, а не булевы сравнения.

```interton
adding std.io

call main() -> int {
    int x = 8 >< 3
    int y = 8 <> 3
    float a = 2.5 >< 4.1
    float b = 2.5 <> 4.1

    inscribe("x:", x)
    inscribe("y:", y)
    inscribe("a:", a)
    inscribe("b:", b)
    return 0
}
```

Ожидаемый вывод:

```text
x: 8
y: 3
a: 4.1
b: 2.5
```

Важный нюанс текущей реализации (`beta-v_.6.1`):

1. в `if (...)` и других логических контекстах результат `<>`/`><` трактуется как truthy/falsy,
2. при присваивании в `bool` сейчас сохраняется числовой результат, который затем оценивается логически при использовании в условии.

```interton
adding std.io

call main() -> int {
    bool c = 8 >< 3
    bool d = 0 <> 3
    inscribe("c:", c, "d:", d)

    if (c) {
        inscribe("c_true")
    } else {
        inscribe("c_false")
    }

    if (d) {
        inscribe("d_true")
    } else {
        inscribe("d_false")
    }
    return 0
}
```

Ожидаемый вывод:

```text
c: 8 d: 0
c_true
d_false
```

## 3. Арифметика

```interton
adding std.io

call main() -> int {
    int p = 2 ** 5
    int d = 17 // 3
    int m1 = 17 % 3
    int m2 = 17 %% 3
    float q = 7 / 2

    inscribe("pow:", p)
    inscribe("int_div:", d)
    inscribe("%:", m1)
    inscribe("%%:", m2)
    inscribe("div:", q)
    return 0
}
```

Ожидаемый вывод:

```text
pow: 32
int_div: 5
%: 2
%%: 2
div: 3.5
```

Примечание:

1. `//` всегда целочисленное деление.
2. `**` возведение в степень.
3. `%` и `%%` оба поддерживаются синтаксически; в числовом коде ведут себя как модуль.

## 4. Равенство и строгие сравнения

```interton
adding std.io

call main() -> int {
    inscribe("5 == 5:", 5 == 5)
    inscribe("5 != 7:", 5 != 7)
    inscribe("5 === 5:", 5 === 5)
    inscribe("5 !== 7:", 5 !== 7)
    inscribe("3 < 9:", 3 < 9)
    inscribe("3 >= 9:", 3 >= 9)
    return 0
}
```

Ожидаемый вывод:

```text
5 == 5: true
5 != 7: true
5 === 5: true
5 !== 7: true
3 < 9: true
3 >= 9: false
```

## 5. Логические операторы

```interton
adding std.io

call main() -> int {
    bool a = true
    bool b = false
    inscribe("a && b:", a && b)
    inscribe("a || b:", a || b)
    inscribe("!a:", !a)
    return 0
}
```

Ожидаемый вывод:

```text
a && b: false
a || b: true
!a: false
```

## 6. Битовые операции

```interton
adding std.io

call main() -> int {
    int a = 6      // 110
    int b = 3      // 011
    inscribe("a & b:", a & b)     // 2
    inscribe("a | b:", a | b)     // 7
    inscribe("a ^ b:", a ^ b)     // 5
    inscribe("a << 1:", a << 1)   // 12
    inscribe("a >> 1:", a >> 1)   // 3
    return 0
}
```

Ожидаемый вывод:

```text
a & b: 2
a | b: 7
a ^ b: 5
a << 1: 12
a >> 1: 3
```

## 7. Составные присваивания

```interton
adding std.io

call main() -> int {
    int v = 10
    v += 2
    v *= 3
    v //= 4
    v **= 2
    v %= 5
    inscribe("v:", v)
    return 0
}
```

Ожидаемый вывод:

```text
v: 4
```

## 8. Диапазоны и доступ

```interton
adding std.io

call main() -> int {
    int[] arr = [10, 20, 30, 40, 50]
    inscribe("len:", |arr|)
    inscribe("first:", arr[0])
    inscribe("slice:", arr[1..3].to_string())
    return 0
}
```

Ожидаемый вывод:

```text
len: 5
first: 10
slice: [20, 30, 40]
```

## 9. Приоритет операторов (важное)

Сверху вниз: от низкого к высокому приоритету.

1. присваивания и `->`,
2. `||`,
3. `&&`,
4. `==`, `!=`, `===`, `!==`,
5. `<`, `<=`, `>`, `>=`, `<>`, `><`, `..`, `<<`, `>>`,
6. `+`, `-`,
7. `*`, `/`, `%`, `//`, `%%`, `|`,
8. `**`,
9. `|>`.

Практическое правило:

1. в длинных выражениях ставьте скобки даже если знаете приоритет,
2. `<>`/`><` используйте осознанно как min/max-операторы,
3. не смешивайте в одной строке арифметику, битовые и логические операции без скобок.

## 10. Типичные ошибки

1. Ожидать, что `<>` вернет `bool`:
   Факт: возвращается одно из значений-операндов (минимум). Логическое поведение появляется только в контексте условия.
2. Путать `%` и `%%` в код-ревью:
   Рекомендация: фиксируйте единый стиль (`%` или `%%`) в командном style guide.
3. Считать `|` логическим OR:
   `|` битовый оператор, логический OR это `||`.
