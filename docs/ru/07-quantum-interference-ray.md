# Interton: quantum/interference/ray — подробный пользовательский гайд

Целевая версия: `Interton beta-v_.6.1`

## 1. Что вы изучите в этом файле

1. какие quantum/interference типы доступны пользователю,
2. **какой тип что именно хранит**,
3. в чем разница между типами,
4. как работает интерференционное кеширование переменных,
5. как использовать `interference.*` и `interf.*`,
6. как включать ray-сценарии.

## 2. Quantum-типы: что хранят и чем отличаются

| Тип | Что хранит | Пример значения | Когда применять | Статус в beta-v_.6.1 |
|---|---|---|---|---|
| `quant_i` | квантовое состояние с целочисленной интерпретацией измерения | `H(|0>)` + `measure(...) -> int` | дискретные квантовые сценарии с выводом в `int` | публичный |
| `quant_f` | квантовое состояние с числовой (float) интерпретацией амплитуд/состояния | `|0>`, `|1>` | смешанные расчеты, где нужен float-контур | публичный |
| `qubit` | одиночный квантовый контейнер состояния | `qubit q = |0>` | моделирование отдельного кубита | публичный |
| `gate` | описание/маркировка квантовой операции | `gate g = H` | построение/описание квантовых шагов | публичный (ограниченный runtime-смысл) |
| `quant_b` | булев квантовый контейнер (internal-уровень) | - | прямой пользовательский синтаксис не использовать | internal/reserved |

Практический вывод:

1. в прикладном коде используйте `quant_i`, `quant_f`, `qubit`,
2. `quant_b` не закладывайте в публичные API проекта.

## 3. Interference-типы: что хранят и чем отличаются

| Тип | Что хранит | Пример значения | Когда применять | Статус в beta-v_.6.1 |
|---|---|---|---|---|
| `interf_i` | буфер/историю целых значений (кеш-переменная) | `[10, 20, 30]` | счетчики, дискретные метрики, кеш int-состояний | публичный |
| `interf_f` | буфер/историю float-значений | `[0.15, 0.27, 0.31]` | непрерывные сигналы, веса, коэффициенты | публичный |
| `interf_s` | буфер строковых значений | `['a','b']` | строковые кеш-сценарии | internal/experimental |
| `interf_b` | буфер bool-состояний | `[true,false,true]` | булевые флаги/сигналы | internal/experimental |

Ключевая разница `interf_i` vs `interf_f`:

1. `interf_i` - дискретная целочисленная история,
2. `interf_f` - дробная/непрерывная история.

## 4. Как работает интерференционный кеш переменных

Важно: это про `interf_*`, а не про `%%tunnel%%`.

Модель кеш-переменной:

1. хранит историю значений,
2. поддерживает индексный доступ,
3. позволяет работать с размером/порядком элементов,
4. предназначена для быстрого повторного использования локальной динамики значений.

### 4.1 Пример `cache_demo.it`

Файл: `examples/interference/cache_demo.it`

Фактические строки вывода:

```text
First element: 10
Last element: 50
Cache size: 5
```

```text
After adding 100: [100]
After adding 200: [100, 200]
After adding 300: [100, 200, 300]
```

### 4.2 Дополнительный пример `resonance.it`

Файл: `examples/interference/resonance.it`

Фактический вывод:

```text
Cache entries: [5, 10, 20]
Resonance pattern: []
```

Это показывает:

1. `interf_*` хранит историю значений корректно,
2. не все выражения над интерференционными типами дают интуитивную форму результата,
3. для production используйте проверенный набор операций и отдельные smoke-кейсы.

## 5. `interf_*` (кеш-переменная) vs `%%tunnel%%` (кеш-функция)

Разделение:

1. `interf_*` - кеш/история **состояния переменной**,
2. `%%tunnel%%` - кеш **результатов вызова функции**.

Примеры tunnel:

1. `examples/basic/cache_tunnel_variants2.it`,
2. `examples/all_examples/14_tunnel_cache.it`.

## 6. Операторы `><` и `<>`

Текущая семантика в beta-v_.6.1:

1. `><` = `max(left, right)`,
2. `<>` = `min(left, right)`.

Пример:

```interton
adding std.io

call main() -> int {
    inscribe("7 >< 3 =", 7 >< 3)
    inscribe("7 <> 3 =", 7 <> 3)
    inscribe("2.5 >< 9 =", 2.5 >< 9)
    inscribe("2.5 <> 9 =", 2.5 <> 9)
    return 0
}
```

Фактический вывод:

```text
7 >< 3 = 7
7 <> 3 = 3
2.5 >< 9 = 9
2.5 <> 9 = 2.5
```

## 7. `interference.*` vs `interf.*`

Разделение обязанностей:

1. `interf.*` - компактные math/wave utility функции,
2. `interference.*` - более физические модели (light/sound/quantum).

Пример модулей:

1. `interf.math`, `interf.wave`,
2. `interference.light`, `interference.sound`, `interference.quantum`.

## 8. Ray tracing: где используется

`rendering.ray` нужен для:

1. описания сцены,
2. расчета изображения,
3. экспорта результата.

Базовые примеры:

1. `examples/all_examples/23_ray_tracing_mini.it`,
2. `examples/ray_tracing/*.it`.

## 9. Мини-чеклист для новичка

1. Начните с `quant_i` + `measure`.
2. Отдельно протестируйте `interf_i` и `interf_f`.
3. Не смешивайте в голове `interf_*` и `%%tunnel%%`.
4. Проверьте `><`/`<>` на собственных данных.
5. Только после этого переходите к `interference.*` и `rendering.ray`.
